name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  schedule:
    - cron: '0 0 * * *'  # Nightly build at midnight
  workflow_dispatch:     # Manual trigger
    inputs:
      run_tests:
        description: 'Run smoke tests'
        type: boolean
        default: true

env:
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
  PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
  EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
  EC2_KEY_NAME: ${{ secrets.EC2_KEY_NAME }}
  TEST_SG_ID: ${{ secrets.TEST_SG_ID }}
  PUBLIC_SUBNET_ID: ${{ secrets.PUBLIC_SUBNET_ID }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ env.TAG }}
    steps:
      - name: Checkout Source Repository
        uses: actions/checkout@v4
        with:
          repository: "zmehta2/Spring-Boot-Angular-8-CRUD-Example"
          token: ${{ env.PAT_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          aws-session-token: ${{ env.AWS_SESSION_TOKEN }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Set Image Tags
        run: |
          if [[ "$GITHUB_REF" != "refs/heads/main" && "$GITHUB_REF" != "refs/heads/master" ]]; then
            BRANCH=${GITHUB_REF##*/}
            TAG="${BRANCH}-$(git rev-parse --short HEAD)"
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
          else
            TAG=$(git rev-parse --short HEAD)
          fi

          echo "TAG=$TAG" >> $GITHUB_ENV

          if [[ "$GITHUB_REF" == "refs/heads/main" || "$GITHUB_REF" == "refs/heads/master" ]]; then
            echo "LATEST_TAG=latest" >> $GITHUB_ENV
          fi

      - name: Build and Tag Docker Images
        run: |
          docker build -t $ECR_REGISTRY/backend:$TAG ./springboot2-jpa-crud-example
          docker build -t $ECR_REGISTRY/frontend:$TAG ./angular8-springboot-client

          if [[ -n "${{ env.LATEST_TAG }}" ]]; then
            docker tag $ECR_REGISTRY/backend:$TAG $ECR_REGISTRY/backend:latest
            docker tag $ECR_REGISTRY/frontend:$TAG $ECR_REGISTRY/frontend:latest
          fi

      - name: Push Images to ECR
        run: |
          docker push $ECR_REGISTRY/backend:$TAG
          docker push $ECR_REGISTRY/frontend:$TAG

          if [[ -n "${{ env.LATEST_TAG }}" ]]; then
            docker push $ECR_REGISTRY/backend:latest
            docker push $ECR_REGISTRY/frontend:latest
          fi

  smoke_test:
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.run_tests != 'false' }}
    steps:
      - name: Checkout Infrastructure Repository
        uses: actions/checkout@v4
        with:
          token: ${{ env.PAT_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          aws-session-token: ${{ env.AWS_SESSION_TOKEN }}

      - name: Create EC2 Userdata Script
        run: |
          mkdir -p config
          cat > config/test-ec2-userdata.sh << 'EOF'
          #!/bin/bash
          yum update -y
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          usermod -a -G docker ec2-user
          curl -L "https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
          yum install -y jq nc
          EOF
          chmod +x config/test-ec2-userdata.sh

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.EC2_SSH_KEY }}" > ~/.ssh/ec2-key.pem
          chmod 600 ~/.ssh/ec2-key.pem

      - name: Launch Test EC2 Instance
        id: launch-ec2
        run: |
          echo "Using image tag: ${{ needs.build.outputs.image_tag }}"

          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=amzn2-ami-hvm-*-x86_64-gp2" "Name=state,Values=available" \
            --query "sort_by(Images, &CreationDate)[-1].ImageId" \
            --output text)
          echo "Using AMI: $AMI_ID"

          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id $AMI_ID \
            --instance-type t2.micro \
            --key-name ${{ env.EC2_KEY_NAME }} \
            --security-group-ids ${{ env.TEST_SG_ID }} \
            --subnet-id ${{ env.PUBLIC_SUBNET_ID }} \
            --associate-public-ip-address \
            --user-data file://config/test-ec2-userdata.sh \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=TestInstance-${{ needs.build.outputs.image_tag }} }]" \
            --query 'Instances[0].InstanceId' \
            --output text)
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

          for i in {1..30}; do
            if nc -z -w5 $PUBLIC_IP 22; then
              break
            fi
            sleep 10
          done

      - name: Create Test Scripts
        run: |
          mkdir -p scripts templates
          cat > scripts/ecr-login.sh << 'EOF'
          #!/bin/bash
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY
          EOF
          cat > scripts/run-tests.sh << 'EOF'
          #!/bin/bash
          sleep 20
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:4200)
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/employees)
          if [[ "$FRONTEND_STATUS" -ne 200 || "$BACKEND_STATUS" -ne 200 ]]; then
            exit 1
          fi
          exit 0
          EOF
          cat > templates/docker-compose.test.yml << 'EOF'
          version: '3'
          services:
            mysqldb:
              image: mysql:8.0
              environment:
                MYSQL_DATABASE: users_database
                MYSQL_ROOT_PASSWORD: test_password
            backend:
              image: ${ECR_REGISTRY}/backend:${TAG}
              environment:
                MYSQL_HOST: mysqldb
                MYSQL_USER: root
                MYSQL_PASSWORD: test_password
            frontend:
              image: ${ECR_REGISTRY}/frontend:${TAG}
          EOF

      - name: Wait for Instance Setup
        run: |
          sleep 30

      - name: Deploy and Test
        id: deploy-test
        run: |
          TAG="${{ needs.build.outputs.image_tag }}"
          # Add StrictHostKeyChecking=no to SCP command
          scp -i ~/.ssh/ec2-key.pem -o StrictHostKeyChecking=no scripts/*.sh templates/docker-compose.test.yml ec2-user@${{ env.PUBLIC_IP }}:~/
          ssh -i ~/.ssh/ec2-key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.PUBLIC_IP }} << EOF
          ls -la
          chmod +x *.sh
          EOF

#          # Add StrictHostKeyChecking=no to SSH command
#          ssh -i ~/.ssh/ec2-key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.PUBLIC_IP }} << EOF
#          # Make scripts executable
#          chmod +x *.sh

          # Set environment variables
          export ECR_REGISTRY="821625964871.dkr.ecr.us-east-1.amazonaws.com"
          export TAG="cea4791"
          export AWS_ACCESS_KEY_ID="${{ env.AWS_ACCESS_KEY_ID }}"
          export AWS_SECRET_ACCESS_KEY="${{ env.AWS_SECRET_ACCESS_KEY }}"
          export AWS_REGION="${{ env.AWS_REGION }}"
          export AWS_SESSION_TOKEN="${{ env.AWS_SESSION_TOKEN }}"

          echo "AWS_REGION is set to $AWS_REGION"
          echo "AWS_SESSION_TOKEN is set to $AWS_SESSION_TOKEN"
          echo "ECR_REGISTRY is set to $ECR_REGISTRY"
          echo "TAG is set to $TAG"
          echo "Logging into ECR at $ECR_REGISTRY..."
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

          # Verify login worked by trying a direct pull
          echo "Testing docker pull directly..."
          docker pull 821625964871.dkr.ecr.us-east-1.amazonaws.com/backend:"cea4791" || echo "Direct pull failed"
          docker pull 821625964871.dkr.ecr.us-east-1.amazonaws.com/frontend:"cea4791" || echo "Direct frontend pull failed"

          # Create an environment file
          echo "ECR_REGISTRY=$ECR_REGISTRY" > .env
          echo "TAG=$TAG" >> .env

          # Use the correct docker-compose file
          echo "Starting docker-compose with ECR_REGISTRY=$ECR_REGISTRY and TAG=$TAG"
          # Use the file we copied over (docker-compose.test.yml)
          docker-compose -f docker-compose.test.yml --env-file .env up -d
          echo "Docker-compose up complete"

          # Run tests
          echo "Running tests..."
#          ./run-tests.sh
#          exit \$?
          curl -s -o /dev/null -w "%{http_code}" http://localhost:8080//springboot-crud-rest/api/v1/employees | grep -q 200 || exit 1
          echo "Backend test successfull with status 200"
          EOF
            
          # Store test result
          TEST_RESULT=$?
          echo "::set-output name=test_result::$TEST_RESULT"
          echo "TEST_RESULT=$TEST_RESULT" >> $GITHUB_ENV
            
          # For debugging
          if [ $TEST_RESULT -eq 0 ]; then
            echo "Tests passed successfully!"
          else
            echo "Tests failed with exit code $TEST_RESULT"
          fi
        continue-on-error: true

      - name: Process Test Results
        run: |
            echo "Test result was: ${{ env.TEST_RESULT }}"
            
            if [ "${{ env.TEST_RESULT }}" == "0" ]; then
              # Tests passed, tag images as QA-ready
              echo "Creating tag-images.sh script..."
              cat > scripts/tag-images.sh << 'EOF'
              #!/bin/bash
              aws ecr batch-get-image --repository-name backend --image-ids imageTag=$1 --query 'images[].imageManifest' --output text | aws ecr put-image --repository-name backend --image-tag QA-ready --image-manifest -
              aws ecr batch-get-image --repository-name frontend --image-ids imageTag=$2 --query 'images[].imageManifest' --output text | aws ecr put-image --repository-name frontend --image-tag QA-ready --image-manifest -
              EOF
              chmod +x scripts/tag-images.sh
            
              echo "Tagging images as QA-ready..."
              ./scripts/tag-images.sh "${{ needs.build.outputs.image_tag }}" "${{ needs.build.outputs.image_tag }}"
              echo "Tests passed, images tagged as QA-ready"
            else
              # Tests failed, remove images
              echo "Creating remove-images.sh script..."
              cat > scripts/remove-images.sh << 'EOF'
              #!/bin/bash
              aws ecr batch-delete-image --repository-name backend --image-ids imageTag=$1
              aws ecr batch-delete-image --repository-name frontend --image-ids imageTag=$2
              EOF
              chmod +x scripts/remove-images.sh
            
              echo "Removing failed images..."
              ./scripts/remove-images.sh "${{ needs.build.outputs.image_tag }}" "${{ needs.build.outputs.image_tag }}"
              echo "Tests failed, images removed from ECR"
              exit 1
            fi

      - name: Cleanup EC2 Instance
        if: always()
        run: |
            echo "Terminating EC2 instance ${{ env.INSTANCE_ID }}"
            aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ID }}
            echo "Test EC2 instance terminated"
          
