name: CI/CD Pipeline

on:
  schedule:
    - cron: '0 0 * * *'  # Nightly build at midnight
  workflow_dispatch:     # Manual trigger
    inputs:
      run_tests:
        description: 'Run smoke tests'
        type: boolean
        default: true

env:
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ env.TAG }}
    steps:
      - name: Checkout Source Repository
        uses: actions/checkout@v4
        with:
          repository: "zmehta2/Spring-Boot-Angular-8-CRUD-Example"
          token: ${{ secrets.PAT_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Set Image Tags
        run: |
          # For development/feature branches
          if [[ "$GITHUB_REF" != "refs/heads/main" && "$GITHUB_REF" != "refs/heads/master" ]]; then
            BRANCH=${GITHUB_REF##*/}
            TAG="${BRANCH}-$(git rev-parse --short HEAD)"
          # For release branches
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
          # For main/master branch
          else
            TAG=$(git rev-parse --short HEAD)
          fi

          echo "TAG=$TAG" >> $GITHUB_ENV

          # Always tag with "latest" for the main branch as well
          if [[ "$GITHUB_REF" == "refs/heads/main" || "$GITHUB_REF" == "refs/heads/master" ]]; then
            echo "LATEST_TAG=latest" >> $GITHUB_ENV
          fi

      - name: Build and Tag Docker Images
        run: |
          # Build backend image
          docker build -t $ECR_REGISTRY/backend:$TAG ./springboot2-jpa-crud-example

          # Build frontend image
          docker build -t $ECR_REGISTRY/frontend:$TAG ./angular8-springboot-client

          # Tag with latest if on main branch
          if [[ -n "${{ env.LATEST_TAG }}" ]]; then
            docker tag $ECR_REGISTRY/backend:$TAG $ECR_REGISTRY/backend:latest
            docker tag $ECR_REGISTRY/frontend:$TAG $ECR_REGISTRY/frontend:latest
          fi

      - name: Push Images to ECR
        run: |
          docker push $ECR_REGISTRY/backend:$TAG
          docker push $ECR_REGISTRY/frontend:$TAG

          # Push latest tags if on main branch
          if [[ -n "${{ env.LATEST_TAG }}" ]]; then
            docker push $ECR_REGISTRY/backend:latest
            docker push $ECR_REGISTRY/frontend:latest
          fi

  smoke_test:
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.run_tests != 'false' }}
    steps:
      - name: Checkout Infrastructure Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Create EC2 Userdata Script
        run: |
          mkdir -p config
          cat > config/test-ec2-userdata.sh << 'EOF'
          #!/bin/bash
          # Update system and install Docker
          yum update -y
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          usermod -a -G docker ec2-user
          
          # Install Docker Compose
          curl -L "https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          EOF
          chmod +x config/test-ec2-userdata.sh

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2-key.pem
          chmod 600 ~/.ssh/ec2-key.pem

      - name: Launch Test EC2 Instance
        id: launch-ec2
        run: |
          echo "Using image tag: ${{ needs.build.outputs.image_tag }}"
          
          # Get latest Amazon Linux 2 AMI
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=amzn2-ami-hvm-*-x86_64-gp2" "Name=state,Values=available" \
            --query "sort_by(Images, &CreationDate)[-1].ImageId" \
            --output text)
          
          echo "Using AMI: $AMI_ID"
          
          # Launch EC2 instance with public IP
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id $AMI_ID \
            --instance-type t2.micro \
            --key-name ${{ secrets.EC2_KEY_NAME }} \
            --security-group-ids ${{ secrets.TEST_SG_ID }} \
            --subnet-id ${{ secrets.PUBLIC_SUBNET_ID }} \
            --associate-public-ip-address \
            --user-data file://config/test-ec2-userdata.sh \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=TestInstance-${{ needs.build.outputs.image_tag }}}]" \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          
          # Wait for instance to be running
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          
          # Get public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "The EC2 instance is running with IP: $PUBLIC_IP"
          
          # Wait for SSH to be available (important!)
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            echo "Attempt $i to connect to SSH..."
            if nc -z -w5 $PUBLIC_IP 22; then
              echo "SSH is available now"
              break
            fi
          
            if [ $i -eq 30 ]; then
              echo "SSH still not available after 30 attempts"
              exit 1
            fi
          
            sleep 10
          done

      - name: Create Test Scripts
        run: |
          mkdir -p scripts templates
          
          # Create Docker setup script
          cat > scripts/setup-docker.sh << 'EOF'
          #!/bin/bash
          echo "Docker is already installed by userdata script"
          exit 0
          EOF
          
          # Create ECR login script
          cat > scripts/ecr-login.sh << 'EOF'
          #!/bin/bash
          aws ecr get-login-password --region $1 | docker login --username AWS --password-stdin $ECR_REGISTRY
          EOF
          
          # Create test script
          cat > scripts/run-tests.sh << 'EOF'
          #!/bin/bash
          # Wait for services to start
          echo "Waiting for services to start..."
          sleep 20
          
          # Test backend API
          echo "Testing backend API..."
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/employees)
          
          echo "Backend status: $BACKEND_STATUS"
          
          if [[ "$BACKEND_STATUS" -ne 200 ]]; then
            echo "Backend test failed with status $BACKEND_STATUS"
            exit 1
          fi
          
          # Test frontend
          echo "Testing frontend..."
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:80)
          
          echo "Frontend status: $FRONTEND_STATUS"
          
          if [[ "$FRONTEND_STATUS" -ne 200 ]]; then
            echo "Frontend test failed with status $FRONTEND_STATUS"
            exit 1
          fi
          
          echo "All tests passed successfully!"
          exit 0
          EOF
          
          # Create Docker Compose file
          cat > templates/docker-compose.test.yml << 'EOF'
          version: '3'
          
          services:
            mysqldb:
              image: mysql:8.0
              container_name: mysqldb
              ports:
                - 3306:3306
              environment:
                MYSQL_DATABASE: users_database
                MYSQL_ROOT_PASSWORD: test_password
              networks:
                - app-network
          
            backend:
              image: ${ECR_REGISTRY}/backend:${TAG}
              container_name: backend
              restart: always
              ports:
                - "8080:8080"
              environment:
                MYSQL_HOST: mysqldb
                MYSQL_USER: root
                MYSQL_PASSWORD: test_password
                MYSQL_PORT: 3306
              depends_on:
                - mysqldb
              networks:
                - app-network
          
            frontend:
              image: ${ECR_REGISTRY}/frontend:${TAG}
              container_name: frontend
              ports:
                - "80:4200"
              depends_on:
                - backend
              networks:
                - app-network
          
          networks:
            app-network:
              driver: bridge
          EOF
          
          chmod +x scripts/*.sh

      - name: Wait for Instance Setup
        run: |
          echo "Waiting 60 seconds for EC2 instance to complete setup..."
          sleep 60

      - name: Deploy and Test
        id: deploy-test
        run: |
          echo "Connecting to EC2 at IP: ${{ env.PUBLIC_IP }}"
          
          # Copy scripts and config to EC2
          scp -i ~/.ssh/ec2-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=60 \
            scripts/setup-docker.sh \
            scripts/ecr-login.sh \
            scripts/run-tests.sh \
            templates/docker-compose.test.yml \
            ec2-user@${{ env.PUBLIC_IP }}:~/
          
          # Run setup and tests
          ssh -i ~/.ssh/ec2-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=60 ec2-user@${{ env.PUBLIC_IP }} << EOF
            # Setup environment variables
            export ECR_REGISTRY=$ECR_REGISTRY
            export TAG=${{ needs.build.outputs.image_tag }}
            export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            export AWS_REGION=${{ secrets.AWS_REGION }}
            export AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }}
          
            # Log into ECR
            chmod +x ecr-login.sh
            ./ecr-login.sh $AWS_REGION
          
            # Start containers
            mv docker-compose.test.yml docker-compose.yml
            echo "Starting containers with images: $ECR_REGISTRY/backend:$TAG and $ECR_REGISTRY/frontend:$TAG"
            sudo -E docker-compose up -d
          
            # Run tests
            chmod +x run-tests.sh
            sudo -E ./run-tests.sh
            TEST_EXIT=\$?
            echo "Test exit code: \$TEST_EXIT"
            exit \$TEST_EXIT
          EOF
          
          # Store test result
          TEST_RESULT=$?
          echo "TEST_RESULT=$TEST_RESULT" >> $GITHUB_ENV
          
          if [ $TEST_RESULT -eq 0 ]; then
            echo "Tests passed successfully!"
          else
            echo "Tests failed with exit code $TEST_RESULT"
          fi

      - name: Tag Images as QA-Ready
        if: ${{ env.TEST_RESULT == '0' }}
        run: |
          # Tag backend image as QA-ready
          aws ecr batch-get-image \
            --repository-name backend \
            --image-ids imageTag=${{ needs.build.outputs.image_tag }} \
            --query 'images[].imageManifest' \
            --output text | aws ecr put-image \
            --repository-name backend \
            --image-tag QA-ready \
            --image-manifest -
          
          # Tag frontend image as QA-ready
          aws ecr batch-get-image \
            --repository-name frontend \
            --image-ids imageTag=${{ needs.build.outputs.image_tag }} \
            --query 'images[].imageManifest' \
            --output text | aws ecr put-image \
            --repository-name frontend \
            --image-tag QA-ready \
            --image-manifest -
          
          echo "Images successfully tagged as QA-ready"

      - name: Remove Failed Images
        if: ${{ env.TEST_RESULT != '0' }}
        run: |
          # Remove backend image
          aws ecr batch-delete-image \
            --repository-name backend \
            --image-ids imageTag=${{ needs.build.outputs.image_tag }}
          
          # Remove frontend image
          aws ecr batch-delete-image \
            --repository-name frontend \
            --image-ids imageTag=${{ needs.build.outputs.image_tag }}
          
          echo "Failed images removed from ECR"

      - name: Cleanup EC2 Instance
        if: always()
        run: |
          if [[ -n "${{ env.INSTANCE_ID }}" ]]; then
            echo "Terminating EC2 instance ${{ env.INSTANCE_ID }}"
            aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ID }}
            echo "Test EC2 instance terminated"
          else
            echo "No instance ID found to terminate"
          fi